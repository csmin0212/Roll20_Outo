<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <!-- 모바일 기기에서도 잘 보이도록 viewport 메타 태그 추가 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Roll20 스타일 매크로 생성기 (개선)</title>
  <!-- Noto Sans KR 웹폰트 임포트 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
  
  <style>
    /* * --- 새롭게 개선된 스타일 ---
     */
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      /* Noto Sans KR 폰트 적용 */
      font-family: 'Noto Sans KR', sans-serif;
      /* 더 세련된 다크 테마 배경색 */
      background: #111827; /* Tailwind Gray 900 */
      color: #e5e7eb; /* Tailwind Gray 200 */
      font-size: 14px;
      line-height: 1.6;
    }
    .app {
      display: flex;
      flex-direction: column;
      gap: 24px; /* 간격 증가 */
      padding: 24px; /* 패딩 증가 */
      min-height: 100vh;
      /* 앱 최대 너비를 설정하고 중앙 정렬 */
      max-width: 1280px;
      margin: 0 auto;
    }
    .top-row {
      display: flex;
      flex-direction: row;
      gap: 24px;
    }
    .panel {
      /* 패널 배경색 변경 */
      background: #1f2937; /* Tailwind Gray 800 */
      border-radius: 16px; /* 모서리 곡률 증가 */
      padding: 24px; /* 패딩 증가 */
      /* 모던한 그림자 효과 */
      box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05);
      border: 1px solid #374151; /* 은은한 테두리 */
    }
    .panel-top {
      flex: 1 1 0;
      display: flex;
      flex-direction: column;
      gap: 16px; /* 내부 간격 */
    }
    .panel-settings {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* === 타이포그래피 (가독성 개선) === */
    h1 {
      font-size: 24px; /* 크기 증가 */
      font-weight: 700;
      margin: 0 0 8px;
      color: #ffffff;
    }
    h2 {
      font-size: 18px; /* 크기 증가 */
      font-weight: 600;
      margin: 12px 0 8px;
      color: #f3f4f6;
      /* 구분선을 h2에 포함시켜 더 깔끔하게 */
      border-bottom: 1px solid #374151;
      padding-bottom: 8px;
    }
    label {
      font-size: 14px; /* 크기 증가 */
      display: block;
      margin-bottom: 6px;
      opacity: 1;
      color: #d1d5db; /* Tailwind Gray 300 */
      font-weight: 500;
    }
    p {
      font-size: 13px;
      opacity: 0.85;
      margin: 0 0 4px;
    }

    /* === 입력창 (Inputs) 스타일 === */
    textarea, input[type="text"], input[type="number"], select {
      width: 100%;
      padding: 10px 12px; /* 패딩 조절 */
      border-radius: 8px; /* 곡률 증가 */
      border: 1px solid #4b5563; /* Tailwind Gray 600 */
      background: #374151; /* Tailwind Gray 700 */
      color: #f3f4f6;
      font-size: 14px;
      resize: vertical;
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    /* 포커스(클릭) 시 하이라이트 */
    textarea:focus, input[type="text"]:focus, input[type="number"]:focus, select:focus {
      border-color: #6366f1; /* Indigo 500 */
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3);
      outline: none;
    }
    textarea {
      min-height: 80px;
      max-height: 200px;
    }

    /* === 색상 선택기 (Color Input) === */
    input[type="color"] {
      padding: 4px;
      border-radius: 8px;
      border: 1px solid #4b5563;
      background: #374151;
      width: 100%; /* 너비 100%로 변경 */
      height: 42px; /* 높이 통일 */
      vertical-align: middle;
      cursor: pointer;
    }
    input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
    }
    input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px; /* 내부 색상 견본 */
    }

    .row {
      display: flex;
      gap: 12px; /* 간격 조절 */
      align-items: center;
    }
    .row > div {
      flex: 1 1 0;
      min-width: 0; /* Flexbox 버그 방지 */
    }
    .checkbox-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 4px;
      font-size: 14px;
    }
    .checkbox-row input[type="checkbox"] {
      width: 16px;
      height: 16px;
      accent-color: #6366f1; /* 체크박스 색상 변경 */
    }
    .checkbox-row label {
      margin: 0;
      font-weight: 400;
    }

    /* === 슬라이더 (Range Input) === */
    .slider-row {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 14px;
    }
    .slider-row span {
      flex-shrink: 0;
    }
    input[type="range"] {
      flex: 1;
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 8px;
      background: #374151; /* 트랙 배경 */
      border-radius: 4px;
      outline: none;
      padding: 0;
      border: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      background: #6366f1; /* 핸들(동그라미) 색상 */
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid #ffffff;
      margin-top: -5px; /* 중앙 정렬 */
    }
    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: #6366f1;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid #ffffff;
    }
    #fontSizeValue, #paddingValue, #radiusValue {
      width: 40px;
      text-align: right;
      color: #9ca3af;
    }

    /* === 버튼 (Button) === */
    button {
      border-radius: 8px;
      border: none;
      background: #4f46e5; /* Indigo 600 */
      color: #ffffff;
      padding: 10px 16px;
      font-size: 14px;
      font-weight: 600;
      font-family: 'Noto Sans KR', sans-serif;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.1s;
      white-space: nowrap;
    }
    button:hover {
      background: #4338ca; /* Indigo 700 */
    }
    button:active {
      transform: translateY(1px);
    }
    .preset-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 4px;
    }
    /* 프리셋 버튼은 약간 다르게 */
    button[data-preset] {
      background-color: #374151;
      font-weight: 500;
    }
    button[data-preset]:hover {
      background-color: #4b5563;
    }

    /* === 작은 버튼 (팔레트) === */
    .tiny-btn {
      padding: 6px 10px;
      font-size: 12px;
      font-weight: 500;
      background-color: #4b5563; /* Gray 600 */
      width: 70px; /* 고정 너비 */
    }
    .tiny-btn:hover {
      background-color: #525b6a;
    }
    
    /* === 커스텀 프리셋 저장 버튼 === */
    #saveCustomPreset {
      background-color: transparent;
      border: 2px dashed #4f46e5;
      color: #6366f1;
      padding: 10px 16px;
      width: 100%;
      transition: background-color 0.2s, color 0.2s;
    }
    #saveCustomPreset:hover {
      background-color: rgba(99, 102, 241, 0.1);
      color: #818cf8;
    }

    /* === 미리보기 (Preview) === */
    .preview-card {
      background: #111827; /* 패널과 구분되는 배경 */
      border-radius: 12px;
      padding: 20px;
      border: 1px solid #374151;
    }
    .preview-header {
      font-size: 13px;
      opacity: 1;
      margin-bottom: 12px;
      color: #9ca3af; /* Gray 400 */
    }
    .preview-wrapper {
      min-height: 80px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: flex-start;
      justify-content: flex-start;
      background: #0b1020; /* 미리보기 배경은 원래대로 어둡게 */
      padding: 16px;
      border-radius: 8px;
    }
    .preview-image {
      max-width: 220px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      display: none;
    }
    .preview-message {
      font-size: 16px; /* 미리보기 폰트 크기 키움 */
      line-height: 1.5;
      word-break: break-word;
    }

    /* === 매크로 코드 출력 (Output) === */
    .macro-output {
      background: #111827; /* Gray 900 */
      border-radius: 12px;
      padding: 16px;
      border: 1px solid #374151;
      display: flex;
      flex-direction: column;
      gap: 10px;
      height: 100%;
    }
    .macro-output label {
      margin-bottom: 0;
      font-weight: 600;
    }
    .macro-output textarea {
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      min-height: 120px;
      flex: 1 1 auto;
      background: #0b1020; /* 코드창은 더 어둡게 */
      border-color: #374151;
    }
    .macro-output p {
      font-size: 12px;
      opacity: 0.7;
    }

    /* === 섹션 구분선 === */
    hr.section-divider {
      border: 0;
      height: 1px;
      background-color: #374151; /* Gray 700 */
      margin: 24px 0; /* 상하 여백 */
    }

    /* === 컬러 모달 (Color Modal) === */
    .color-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      /* 모던한 블러 효과 */
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .color-modal.hidden {
      display: none;
    }
    .color-modal-content {
      background: #1f2937; /* Gray 800 */
      border-radius: 16px;
      padding: 20px 24px;
      width: min(400px, 90vw);
      box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
      border: 1px solid #4b5563; /* Gray 600 */
    }
    .color-modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
    }
    .color-modal-header span {
      font-size: 16px;
      font-weight: 600;
      color: #ffffff;
    }
    .color-modal-header .tiny-btn {
      background-color: #4b5563;
    }
    .color-modal-content p {
      font-size: 13px;
      margin-bottom: 12px;
    }
    .color-grid {
      display: grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap: 10px; /* 간격 조절 */
      margin-top: 8px;
    }
    .color-swatch {
      width: 100%;
      padding: 0; /* 패딩 제거 */
      height: 40px; /* 고정 높이 */
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      cursor: pointer;
      outline: none;
      transition: box-shadow 0.2s, border-color 0.2s;
    }
    .color-swatch:hover {
      border-color: #6366f1;
      box-shadow: 0 0 0 3px #6366f1;
    }
    .color-swatch-label {
      margin-top: 12px;
      font-size: 12px;
      text-align: center;
      opacity: 0.85;
      color: #9ca3af;
    }

    /* === 반응형 레이아웃 === */
    @media (max-width: 900px) {
      .top-row {
        flex-direction: column;
      }
      .app {
        padding: 16px;
        gap: 16px;
      }
      .panel {
        padding: 16px;
      }
    }
    @media (max-width: 600px) {
      /* 모바일에서 2열 컨트롤을 1열로 변경 */
      .row {
        flex-direction: column;
        align-items: stretch;
      }
      input[type="color"] {
        width: 100%;
      }
      .slider-row {
        flex-wrap: wrap;
      }
      .slider-row span:first-child {
        width: 100%;
        margin-bottom: 4px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- 상단: 미리보기 + 코드 -->
    <div class="top-row">
      <div class="panel panel-top">
        <h1>Roll20 스타일 미리보기</h1>
        <div class="preview-card">
          <div class="preview-header">글자 미리보기</div>
          <div class="preview-wrapper">
            <img id="previewImageTop" class="preview-image" alt="preview image top">
            <div id="previewMessage" class="preview-message">
              예시 텍스트입니다. 아래 설정을 조절해 스타일을 바꿔 보세요.
            </div>
            <img id="previewImageBottom" class="preview-image" alt="preview image bottom">
          </div>
        </div>
      </div>

      <div class="panel panel-top">
        <h1>매크로 코드</h1>
        <div class="macro-output">
          <label for="macroText">Roll20 채팅 매크로 코드</label>
          <textarea id="macroText" readonly></textarea>
          <p>
            예시<br>
            [깃털 방패](#" style="...여기에 CSS...") 형식으로 출력됩니다.
          </p>
        </div>
      </div>
    </div>

    <!-- 하단: 설정 패널 -->
    <div class="panel panel-settings">
      <h2>1. 텍스트 입력</h2>
      <label for="inputText">채팅 내용</label>
      <textarea id="inputText" placeholder="예: 적의 공격을 피하고 반격한다."></textarea>

      <hr class="section-divider">

      <h2>2. 글자 크기</h2>
      <div class="slider-row">
        <span>글자 크기(px)</span>
        <input type="range" id="fontSizeRange" min="10" max="36" value="18">
        <span id="fontSizeValue">18px</span>
      </div>

      <hr class="section-divider">

      <h2>3. 색상 · 배경 · 테두리</h2>
      <div class="row">
        <div>
          <label for="fontColor">글자 색</label>
          <div class="row">
            <input type="color" id="fontColor" value="#ffffff">
            <button type="button" class="tiny-btn openColorPicker" data-target="fontColor" data-label="글자 색">팔레트</button>
          </div>
        </div>
        <div>
          <label for="bgColor">배경 색</label>
          <div class="row">
            <input type="color" id="bgColor" value="#14192b">
            <button type="button" class="tiny-btn openColorPicker" data-target="bgColor" data-label="배경 색">팔레트</button>
          </div>
        </div>
      </div>

      <div class="slider-row">
        <span>배경 패딩</span>
        <input type="range" id="paddingRange" min="0" max="32" value="10">
        <span id="paddingValue">10px</span>
      </div>

      <div class="slider-row">
        <span>모서리 곡률</span>
        <input type="range" id="radiusRange" min="0" max="32" value="8">
        <span id="radiusValue">8px</span>
      </div>

      <div class="checkbox-row">
        <input type="checkbox" id="borderToggle" checked>
        <label for="borderToggle">테두리 사용</label>
      </div>

      <div class="row">
        <div>
          <label for="borderColor">테두리 색</label>
          <div class="row">
            <input type="color" id="borderColor" value="#3a4cff">
            <button type="button" class="tiny-btn openColorPicker" data-target="borderColor" data-label="테두리 색">팔레트</button>
          </div>
        </div>
        <div>
          <label for="borderWidth">두께(px)</label>
          <input type="number" id="borderWidth" value="2" min="0" max="10">
        </div>
      </div>

      <hr class="section-divider">

      <h2>4. 네온 글로우</h2>
      <div class="checkbox-row">
        <input type="checkbox" id="neonToggle" checked>
        <label for="neonToggle">네온 글로우 켜기</label>
      </div>
      <div class="row">
        <div>
          <label for="neonColor">네온 색</label>
          <div class="row">
            <input type="color" id="neonColor" value="#4ef2ff">
            <button type="button" class="tiny-btn openColorPicker" data-target="neonColor" data-label="네온 색">팔레트</button>
          </div>
        </div>
        <div>
          <label for="neonSize">강도(px)</label>
          <input type="number" id="neonSize" value="6" min="0" max="24">
        </div>
      </div>

      <hr class="section-divider">

      <h2>5. 그림자 (계단식)</h2>
      <div class="row">
        <div>
          <label for="shadowSteps">계단 수</label>
          <input type="number" id="shadowSteps" value="3" min="0" max="10">
        </div>
        <div>
          <label for="shadowDistance">간격(px)</label>
          <input type="number" id="shadowDistance" value="2" min="0" max="20">
        </div>
      </div>
      <div class="row">
        <div>
          <label for="shadowAngle">각도(도)</label>
          <input type="number" id="shadowAngle" value="135" min="0" max="360">
        </div>
        <div>
          <label for="shadowColor">그림자 색</label>
          <div class="row">
            <input type="color" id="shadowColor" value="#000000">
            <button type="button" class="tiny-btn openColorPicker" data-target="shadowColor" data-label="그림자 색">팔레트</button>
          </div>
        </div>
      </div>

      <hr class="section-divider">

      <h2>6. 레이아웃 · 이미지</h2>

      <div class="row">
        <div>
          <label for="columnCount">컬럼 개수</label>
          <select id="columnCount">
            <option value="1">1 컬럼 (일반)</option>
            <option value="2">2 컬럼</option>
            <option value="3">3 컬럼</option>
          </select>
        </div>
        <div>
          <label for="maxWidth">최대 너비(px)</label>
          <input type="number" id="maxWidth" value="420" min="0" max="800">
        </div>
      </div>

      <label for="imageUrl">이미지 URL (선택)</label>
      <input type="text" id="imageUrl" placeholder="https:// 예: 아이콘, 일러스트 등">

      <div class="row">
        <div>
          <label for="imagePosition">이미지 위치</label>
          <select id="imagePosition">
            <option value="top">텍스트 위</option>
            <option value="bottom">텍스트 아래</option>
          </select>
        </div>
        <div>
          <label for="imageWidth">이미지 너비(px)</label>
          <input type="number" id="imageWidth" value="180" min="40" max="600">
        </div>
      </div>

      <hr class="section-divider">

      <h2>7. Roll20 스타일 프리셋</h2>
      <p>
        자주 쓰는 스타일을 한 번에 불러올 수 있습니다.
      </p>
      <div class="preset-buttons">
        <button type="button" data-preset="neonAlert">네온 알림</button>
        <button type="button" data-preset="ooc">OOC 메모</button>
        <button type="button" data-preset="system">시스템 로그</button>
      </div>

      <button id="saveCustomPreset" type="button" style="margin-top:16px;">
        현재 설정을 커스텀 프리셋으로 저장 (브라우저 로컬)
      </button>

      <hr class="section-divider">
      
      <!-- 
        *** 버그 수정 ***
        원본 JS에서 참조하던 'macroMode' 요소가 HTML에 없어 추가합니다.
      -->
      <label for="macroMode">매크로 출력 형식</label>
      <select id="macroMode">
        <option value="em">/em (emote)</option>
        <option value="whisper">/w gm (GM 귓속말)</option>
        <option value="templateDefault">기본 템플릿 (rolltemplate: default)</option>
      </select>


      <label for="templateName" style="margin-top: 12px;">템플릿 name (현재는 출력 형식에는 반영 안 됨)</label>
      <input type="text" id="templateName" placeholder="예: Styled Message">
    </div>
  </div>

  <!-- 색상 팔레트 모달 -->
  <div id="colorModal" class="color-modal hidden">
    <div class="color-modal-content">
      <div class="color-modal-header">
        <span id="colorModalTitle">색 선택</span>
        <button type="button" id="colorModalClose" class="tiny-btn">닫기</button>
      </div>
      <p>
        원하는 색을 클릭하면 해당 필드에 색상 코드가 자동으로 들어갑니다.
      </p>
      <div class="color-grid">
        <!-- 밝은 계열 -->
        <button class="color-swatch" data-color="#ffffff" style="background:#ffffff;"></button>
        <button class="color-swatch" data-color="#e5e7ff" style="background:#e5e7ff;"></button>
        <button class="color-swatch" data-color="#ffdde1" style="background:#ffdde1;"></button>
        <button class="color-swatch" data-color="#ffe6b3" style="background:#ffe6b3;"></button>
        <button class="color-swatch" data-color="#e0ffe5" style="background:#e0ffe5;"></button>
        <button class="color-swatch" data-color="#e0fbff" style="background:#e0fbff;"></button>
        <!-- 네온/강렬 -->
        <button class="color-swatch" data-color="#ff2fd1" style="background:#ff2fd1;"></button>
        <button class="color-swatch" data-color="#ff4b4b" style="background:#ff4b4b;"></button>
        <button class="color-swatch" data-color="#ffdd7b" style="background:#ffdd7b;"></button>
        <button class="color-swatch" data-color="#4ef2ff" style="background:#4ef2ff;"></button>
        <button class="color-swatch" data-color="#7dffb2" style="background:#7dffb2;"></button>
        <button class="color-swatch" data-color="#9b5cff" style="background:#9b5cff;"></button>
        <!-- 어두운 배경용 -->
        <button class="color-swatch" data-color="#14192b" style="background:#14192b;"></button>
        <button class="color-swatch" data-color="#202434" style="background:#202434;"></button>
        <button class="color-swatch" data-color="#402808" style="background:#402808;"></button>
        <button class="color-swatch" data-color="#1a0120" style="background:#1a0120;"></button>
        <button class="color-swatch" data-color="#000000" style="background:#000000;"></button>
        <button class="color-swatch" data-color="#3b0030" style="background:#3b0030;"></button>
      </div>
      <div class="color-swatch-label">
        색상 코드는 Hex 형식(#RRGGBB)으로 필드에 입력됩니다.
      </div>
    </div>
  </div>

  <!-- 
    JavaScript 로직은 원본과 동일하게 유지합니다.
    스타일만 변경되었으므로 기능은 동일하게 작동합니다.
  -->
  <script>
    // 요소 선택
    const inputText = document.getElementById("inputText");
    const fontSizeRange = document.getElementById("fontSizeRange");
    const fontSizeValue = document.getElementById("fontSizeValue");

    const fontColor = document.getElementById("fontColor");
    const bgColor = document.getElementById("bgColor");
    const paddingRange = document.getElementById("paddingRange");
    const paddingValue = document.getElementById("paddingValue");
    const radiusRange = document.getElementById("radiusRange");
    const radiusValue = document.getElementById("radiusValue");
    const borderToggle = document.getElementById("borderToggle");
    const borderColor = document.getElementById("borderColor");
    const borderWidth = document.getElementById("borderWidth");

    const neonToggle = document.getElementById("neonToggle");
    const neonColor = document.getElementById("neonColor");
    const neonSize = document.getElementById("neonSize");

    const shadowSteps = document.getElementById("shadowSteps");
    const shadowDistance = document.getElementById("shadowDistance");
    const shadowAngle = document.getElementById("shadowAngle");
    const shadowColor = document.getElementById("shadowColor");

    const columnCount = document.getElementById("columnCount");
    const maxWidth = document.getElementById("maxWidth");

    const imageUrl = document.getElementById("imageUrl");
    const imagePosition = document.getElementById("imagePosition");
    const imageWidth = document.getElementById("imageWidth");

    const previewMessage = document.getElementById("previewMessage");
    const previewImageTop = document.getElementById("previewImageTop");
    const previewImageBottom = document.getElementById("previewImageBottom");
    const macroText = document.getElementById("macroText");

    const presetButtons = document.querySelectorAll("button[data-preset]");
    const saveCustomPresetButton = document.getElementById("saveCustomPreset");

    // 버그 수정을 위해 추가된 'macroMode' 요소 선택
    const macroMode = document.getElementById("macroMode");
    const templateName = document.getElementById("templateName");

    // 컬러 모달 관련
    const colorModal = document.getElementById("colorModal");
    const colorModalTitle = document.getElementById("colorModalTitle");
    const colorModalClose = document.getElementById("colorModalClose");
    const colorSwatches = document.querySelectorAll(".color-swatch");
    const colorPickerButtons = document.querySelectorAll(".openColorPicker");
    let activeColorTarget = null;

    // 값 표시 슬라이더
    function syncSliderLabels() {
      paddingValue.textContent = paddingRange.value + "px";
      radiusValue.textContent = radiusRange.value + "px";
      fontSizeValue.textContent = fontSizeRange.value + "px";
    }

    // Markdown 링크 텍스트 이스케이프 ([텍스트] 안에 들어갈 부분)
    function escapeMarkdownLinkText(text) {
      return text
        .replace(/\\/g, "\\\\")
        .replace(/\]/g, "\\]");
    }

    // 스타일 문자열 생성
    function buildStyleString() {
      const styleEntries = [];

      const fontSizePx = parseInt(fontSizeRange.value, 10) || 0;
      if (fontSizePx > 0) {
        styleEntries.push(["font-size", fontSizePx + "px"]);
      }

      styleEntries.push(["color", fontColor.value]);
      if (bgColor.value) {
        styleEntries.push(["background-color", bgColor.value]);
      }

      const paddingPx = parseInt(paddingRange.value, 10) || 0;
      if (paddingPx > 0) {
        styleEntries.push(["padding", paddingPx + "px"]);
      }

      const radiusPx = parseInt(radiusRange.value, 10) || 0;
      if (radiusPx > 0) {
        styleEntries.push(["border-radius", radiusPx + "px"]);
      }

      const borderWidthPx = parseInt(borderWidth.value, 10) || 0;
      if (borderToggle.checked && borderWidthPx > 0) {
        styleEntries.push(["border", borderWidthPx + "px solid " + borderColor.value]);
      } else {
        styleEntries.push(["border", "none"]);
      }

      const textShadowParts = [];

      if (neonToggle.checked) {
        const glowSize = parseInt(neonSize.value, 10) || 0;
        if (glowSize > 0) {
          textShadowParts.push("0 0 " + glowSize + "px " + neonColor.value);
          textShadowParts.push("0 0 " + glowSize * 2 + "px " + neonColor.value);
        }
      }

      const steps = parseInt(shadowSteps.value, 10) || 0;
      const dist = parseInt(shadowDistance.value, 10) || 0;
      const angleDeg = parseInt(shadowAngle.value, 10) || 0;
      const angleRad = angleDeg * Math.PI / 180;
      const sColor = shadowColor.value;

      if (steps > 0 && dist > 0) {
        for (let i = 1; i <= steps; i += 1) {
          const x = Math.round(Math.cos(angleRad) * dist * i);
          const y = Math.round(Math.sin(angleRad) * dist * i);
          textShadowParts.push(x + "px " + y + "px 0 " + sColor);
        }
      }

      if (textShadowParts.length > 0) {
        styleEntries.push(["text-shadow", textShadowParts.join(", ")]);
      }

      const colCount = parseInt(columnCount.value, 10) || 1;
      if (colCount > 1) {
        styleEntries.push(["column-count", colCount.toString()]);
        styleEntries.push(["column-gap", "12px"]);
      }

      const maxWidthPx = parseInt(maxWidth.value, 10) || 0;
      if (maxWidthPx > 0) {
        styleEntries.push(["max-width", maxWidthPx + "px"]);
      }
      
      // 링크가 항상 블록 요소처럼 보이도록 (배경색 등이 전체 너비에 적용)
      styleEntries.push(["display", "inline-block"]);
      styleEntries.push(["width", "100%"]);
      styleEntries.push(["text-align", "left"]);


      const styleString = styleEntries
        .map(function(entry) {
          return entry[0] + ":" + entry[1];
        })
        .join("; ");

      return styleString;
    }

    // 미리보기 · 매크로 갱신
    function updatePreviewAndMacro() {
      syncSliderLabels();

      const text = inputText.value.trim() || "예시 텍스트입니다. 아래 설정을 조절해 스타일을 바꿔 보세요.";
      const styleString = buildStyleString();

      previewMessage.textContent = text;
      previewMessage.setAttribute("style", styleString.replace(/width:100%/g, '')); // 미리보기에서는 width 100% 제거

      const url = imageUrl.value.trim();
      const widthPx = parseInt(imageWidth.value, 10) || 0;
      const showImage = url.length > 0;
      const position = imagePosition.value;

      if (showImage && widthPx > 0) {
        if (position === "top") {
          previewImageTop.src = url;
          previewImageTop.style.display = "block";
          previewImageTop.style.width = widthPx + "px";
          previewImageBottom.style.display = "none";
        } else {
          previewImageBottom.src = url;
          previewImageBottom.style.display = "block";
          previewImageBottom.style.width = widthPx + "px";
          previewImageTop.style.display = "none";
        }
      } else {
        previewImageTop.style.display = "none";
        previewImageBottom.style.display = "none";
      }

      const linkText = escapeMarkdownLinkText(text);
      const styleForLink = styleString;

      // macroMode 값은 현재 이 로직에서 사용되지 않지만, 프리셋 로직을 위해 존재합니다.
      // (원본 코드와 동일하게 유지)
      const macroBody = `[${linkText}](#" style="${styleForLink}" )`;

      macroText.value = macroBody;
    }

    // 프리셋 정의
    const presets = {
      neonAlert: function () {
        inputText.value = "[ALERT] 강력한 기술이 발동됩니다.";
        fontSizeRange.value = "20";
        fontColor.value = "#ffffff";
        bgColor.value = "#1a0120";
        paddingRange.value = "12";
        radiusRange.value = "10";
        borderToggle.checked = true;
        borderColor.value = "#ff2fd1";
        borderWidth.value = "2";

        neonToggle.checked = true;
        neonColor.value = "#ff2fd1";
        neonSize.value = "8";

        shadowSteps.value = "4";
        shadowDistance.value = "2";
        shadowAngle.value = "135";
        shadowColor.value = "#3b0030";

        columnCount.value = "1";
        maxWidth.value = "420";

        imageUrl.value = "";
        imagePosition.value = "top";
        imageWidth.value = "180";

        macroMode.value = "em";
        templateName.value = "Neon Alert";
      },
      ooc: function () {
        inputText.value = "(OOC) 잠시 물 마시고 올게요.";
        fontSizeRange.value = "16";
        fontColor.value = "#d0d3ff";
        bgColor.value = "#202434";
        paddingRange.value = "8";
        radiusRange.value = "6";
        borderToggle.checked = true;
        borderColor.value = "#4b5475";
        borderWidth.value = "1";

        neonToggle.checked = false;
        neonSize.value = "0";

        shadowSteps.value = "0";
        shadowDistance.value = "0";
        shadowAngle.value = "135";
        shadowColor.value = "#000000";

        columnCount.value = "1";
        maxWidth.value = "360";

        imageUrl.value = "";
        imagePosition.value = "top";
        imageWidth.value = "180";

        macroMode.value = "whisper";
        templateName.value = "OOC Note";
      },
      system: function () {
        inputText.value = "시스템: 라운드가 종료되었습니다.";
        fontSizeRange.value = "18";
        fontColor.value = "#ffdd7b";
        bgColor.value = "#402808";
        paddingRange.value = "8";
        radiusRange.value = "4";
        borderToggle.checked = true;
        borderColor.value = "#ffdd7b";
        borderWidth.value = "1";

        neonToggle.checked = false;
        neonSize.value = "0";

        shadowSteps.value = "2";
        shadowDistance.value = "1";
        shadowAngle.value = "90";
        shadowColor.value = "#000000";

        columnCount.value = "1";
        maxWidth.value = "420";

        imageUrl.value = "";
        imagePosition.value = "top";
        imageWidth.value = "180";

        macroMode.value = "templateDefault";
        templateName.value = "System Log";
      }
    };

    // 커스텀 프리셋 저장 (로컬스토리지)
    function saveCustomPreset() {
      const preset = {
        text: inputText.value,
        fontSize: fontSizeRange.value,
        fontColor: fontColor.value,
        bgColor: bgColor.value,
        padding: paddingRange.value,
        radius: radiusRange.value,
        borderToggle: borderToggle.checked,
        borderColor: borderColor.value,
        borderWidth: borderWidth.value,
        neonToggle: neonToggle.checked,
        neonColor: neonColor.value,
        neonSize: neonSize.value,
        shadowSteps: shadowSteps.value,
        shadowDistance: shadowDistance.value,
        shadowAngle: shadowAngle.value,
        shadowColor: shadowColor.value,
        columnCount: columnCount.value,
        maxWidth: maxWidth.value,
        imageUrl: imageUrl.value,
        imagePosition: imagePosition.value,
        imageWidth: imageWidth.value,
        macroMode: macroMode.value,
        templateName: templateName.value
      };

      try {
        localStorage.setItem("roll20StyleCustomPreset", JSON.stringify(preset));
        saveCustomPresetButton.textContent = "커스텀 프리셋 저장 완료 (이 브라우저에 보존)";
        setTimeout(function () {
          saveCustomPresetButton.textContent = "현재 설정을 커스텀 프리셋으로 저장 (브라우저 로컬)";
        }, 1800);
      } catch (e) {
        console.error("프리셋 저장 실패", e);
        saveCustomPresetButton.textContent = "저장 실패 (로컬스토리지 제한)";
        setTimeout(function () {
          saveCustomPresetButton.textContent = "현재 설정을 커스텀 프리셋으로 저장 (브라우저 로컬)";
        }, 2000);
      }
    }

    function loadCustomPresetIfExists() {
      try {
        const raw = localStorage.getItem("roll20StyleCustomPreset");
        if (!raw) return;
        const p = JSON.parse(raw);
        inputText.value = p.text || "";
        fontSizeRange.value = p.fontSize || fontSizeRange.value;
        fontColor.value = p.fontColor || fontColor.value;
        bgColor.value = p.bgColor || bgColor.value;
        paddingRange.value = p.padding || paddingRange.value;
        radiusRange.value = p.radius || radiusRange.value;
        borderToggle.checked = typeof p.borderToggle === "boolean" ? p.borderToggle : borderToggle.checked;
        borderColor.value = p.borderColor || borderColor.value;
        borderWidth.value = p.borderWidth || borderWidth.value;
        neonToggle.checked = typeof p.neonToggle === "boolean" ? p.neonToggle : neonToggle.checked;
        neonColor.value = p.neonColor || neonColor.value;
        neonSize.value = p.neonSize || neonSize.value;
        shadowSteps.value = p.shadowSteps || shadowSteps.value;
        shadowDistance.value = p.shadowDistance || shadowDistance.value;
        shadowAngle.value = p.shadowAngle || shadowAngle.value;
        shadowColor.value = p.shadowColor || shadowColor.value;
        columnCount.value = p.columnCount || columnCount.value;
        maxWidth.value = p.maxWidth || maxWidth.value;
        imageUrl.value = p.imageUrl || "";
        imagePosition.value = p.imagePosition || imagePosition.value;
        imageWidth.value = p.imageWidth || imageWidth.value;
        macroMode.value = p.macroMode || macroMode.value;
        templateName.value = p.templateName || "";
      } catch (e) {
        console.error("커스텀 프리셋 로드 실패", e);
      }
    }

    const inputsToWatch = [
      inputText,
      fontSizeRange,
      fontColor,
      bgColor,
      paddingRange,
      radiusRange,
      borderToggle,
      borderColor,
      borderWidth,
      neonToggle,
      neonColor,
      neonSize,
      shadowSteps,
      shadowDistance,
      shadowAngle,
      shadowColor,
      columnCount,
      maxWidth,
      imageUrl,
      imagePosition,
      imageWidth,
      macroMode, // 이제 이 요소가 존재하므로 오류가 없습니다.
      templateName
    ];

    inputsToWatch.forEach(function (el) {
      el.addEventListener("input", updatePreviewAndMacro);
      el.addEventListener("change", updatePreviewAndMacro);
    });

    presetButtons.forEach(function (btn) {
      btn.addEventListener("click", function () {
        const key = btn.getAttribute("data-preset");
        const fn = presets[key];
        if (typeof fn === "function") {
          fn();
          updatePreviewAndMacro();
        }
      });
    });

    saveCustomPresetButton.addEventListener("click", function () {
      saveCustomPreset();
    });

    colorPickerButtons.forEach(function (btn) {
      btn.addEventListener("click", function () {
        activeColorTarget = btn.getAttribute("data-target");
        const label = btn.getAttribute("data-label") || "색 선택";
        colorModalTitle.textContent = label + " 선택";
        colorModal.classList.remove("hidden");
      });
    });

    colorSwatches.forEach(function (swatch) {
      swatch.addEventListener("click", function () {
        if (!activeColorTarget) return;
        const color = swatch.getAttribute("data-color");
        const targetInput = document.getElementById(activeColorTarget);
        if (targetInput) {
          targetInput.value = color;
          // input[type=color]의 change 이벤트를 수동으로 발생시켜야 할 수도 있습니다.
          // 여기서는 JS가 'input' 이벤트를 수신하므로 괜찮지만,
          // 확실하게 하기 위해 targetInput.dispatchEvent(new Event('input'));
        }
        colorModal.classList.add("hidden");
        activeColorTarget = null;
        updatePreviewAndMacro();
      });
    });

    colorModalClose.addEventListener("click", function () {
      colorModal.classList.add("hidden");
      activeColorTarget = null;
    });

    colorModal.addEventListener("click", function (e) {
      if (e.target === colorModal) {
        colorModal.classList.add("hidden");
        activeColorTarget = null;
      }
    });

    // 페이지 로드 시 커스텀 프리셋이 있으면 불러오기
    loadCustomPresetIfExists();
    // 초기 값으로 슬라이더 레이블 및 미리보기 갱신
    syncSliderLabels();
    updatePreviewAndMacro();
  </script>
</body>
</html>